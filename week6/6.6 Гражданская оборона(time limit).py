# Штаб гражданской обороны Тридесятой области решил обновить план спасения на случай ядерной атаки.
# Известно, что все n селений Тридесятой области находятся вдоль одной прямой дороги.
# Вдоль дороги также расположены m бомбоубежищ, в которых жители селений могут укрыться на случай ядерной атаки.
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
# необходимо для каждого селения определить ближайшее к нему бомбоубежище.
# Формат ввода
# В первой строке вводится число n - количество селений (1 <= n <= 100000).
# Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
# расстояние от начала дороги до i-го селения. В третьей строке входных данных
# задается число m - количество бомбоубежищ (1 <= m <= 100000).
# Четвертая строка содержит m различных целых чисел, i-е из этих чисел
# задает расстояние от начала дороги до i-го бомбоубежища.
# Все расстояния положительны и не превышают 10⁹. Селение и убежище могут располагаться в одной точке.
# Формат вывода
# Выведите  n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища.
# Бомбоубежища пронумерованы от 1 до m в том порядке, в котором они заданы во входных данных.
# Указание
# Создайте список кортежей из пар (позиция селения, его номер в исходном списке),
# а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.
# Перебирайте селения в порядке возрастания.
# Для селения ближайшими могут быть два соседних бомбоубежища,
# среди них надо выбрать ближайшее. При переходе к следующему селению
# не обязательно искать ближайшее бомбоубежище с самого начала.
# Его можно искать начиная с позиции, найденной для предыдущего города.
# Аналогично, не нужно искать подходящее бомбоубежище до конца списка бомбоубежищ:
# достаточно найти самое близкое. Если Вы неэффективно реализуете эту часть, то решение тесты не пройдет.
# Для хранения ответа используйте список, где индекс будет номером селения,
# а по этому индексу будет запоминаться номер бомбоубежища.
villages_qty = int(input())
v_num = list(map(int, input().split()))
bunkers_qty = int(input())
b_num = list(map(int, input().split()))
v_new, b_new = v_num.copy(), b_num.copy()
v_new.sort(), b_new.sort()
i, j = 0, 1
b_pairs = []
if bunkers_qty == 1:
    for x in v_new:
        b_pairs.append((x, 1))
else:
    for x in v_new:
        a, b = b_new[j - 1], b_new[j]
        i += 1
        if abs(x - a) == abs(x - b):
            b_pairs.append((x, b_num.index(b) + 1))
        elif abs(x - a) < abs(x - b):
            b_pairs.append((x, b_num.index(a) + 1))
        else:
            if j < len(b_new) - 1:
                while abs(x - a) >= abs(x - b):
                    j += 1
                    a, b = b_new[j - 1], b_new[j]
                b_pairs.append((x, b_num.index(a) + 1))
            else:
                b_pairs.append((x, b_num.index(b) + 1))


def f(o):
    return v_num.index(o[0])


b_pairs.sort(key=f)
for y in b_pairs:
    print(y[1], end=" ")
