# Штаб гражданской обороны Тридесятой области решил обновить план спасения на случай ядерной атаки.
# Известно, что все n селений Тридесятой области находятся вдоль одной прямой дороги.
# Вдоль дороги также расположены m бомбоубежищ, в которых жители селений могут укрыться на случай ядерной атаки.
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
# необходимо для каждого селения определить ближайшее к нему бомбоубежище.
# Формат ввода
# В первой строке вводится число n - количество селений (1 <= n <= 100000).
# Вторая строка содержит n различных целых чисел, i-е из этих чисел задает расстояние от начала дороги до i-го селения.
# В третьей строке входных данных задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая строка
# содержит m различных целых чисел, i-е из этих чисел задает расстояние от начала дороги до i-го бомбоубежища.
# Все расстояния положительны и не превышают 10⁹. Селение и убежище могут располагаться в одной точке.
# Формат вывода
# Выведите  n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища.
# Бомбоубежища пронумерованы от 1 до m в том порядке, в котором они заданы во входных данных.
# Указание
# Создайте список кортежей из пар (позиция селения, его номер в исходном списке),
# а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.
# Перебирайте селения в порядке возрастания.
# Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо выбрать ближайшее.
# При переходе к следующему селению не обязательно искать ближайшее бомбоубежище с самого начала.
# Его можно искать начиная с позиции, найденной для предыдущего города. Аналогично, не нужно искать
# подходящее бомбоубежище до конца списка бомбоубежищ: достаточно найти самое близкое.
# Если Вы неэффективно реализуете эту часть, то решение тесты не пройдет.
# Для хранения ответа используйте список, где индекс будет номером селения,
# а по этому индексу будет запоминаться номер бомбоубежища.
n = int(input())
a = list(map(int, input().split()))
m = int(input())
b = list(map(int, input().split()))
for i in range(max(n, m)):
    if i < n:
        a[i] = [a[i], i]
    if i < m:
        b[i] = [b[i], i + 1]
a.sort(), b.sort()
j, k = 0, 0
while j < len(a):
    if k + 1 < len(b):
        if abs(a[j][0] - b[k][0]) <= abs(a[j][0] - b[k + 1][0]):
            a[j].append(b[k][1])
            j += 1
        else:
            k += 1
    else:
        a[j].append(b[k][1])
        j += 1
a.sort(key=lambda x: x[1])
for i1 in range(len(a)):
    print(a[i1][2], end=' ')
